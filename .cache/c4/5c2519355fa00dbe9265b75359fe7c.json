{"id":"node_modules/@bikeshaving/crank/cjs/index-454299da.js","dependencies":[{"name":"/Users/sekdemir/CodeWorks/hobby/crank/node_modules/@bikeshaving/crank/cjs/index-454299da.js.map","includedInParent":true,"mtime":1587766456157},{"name":"/Users/sekdemir/CodeWorks/hobby/crank/package.json","includedInParent":true,"mtime":1587766485304},{"name":"/Users/sekdemir/CodeWorks/hobby/crank/.babelrc","includedInParent":true,"mtime":1587766155824},{"name":"/Users/sekdemir/CodeWorks/hobby/crank/node_modules/@bikeshaving/crank/package.json","includedInParent":true,"mtime":1587766456157}],"generated":{"js":"'use strict';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexports.__assign = function() {\r\n    exports.__assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return exports.__assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\n\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap();\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event);\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    );\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            );\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    });\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true });\n\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this));\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype);\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event);\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value;\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    });\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            );\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nfunction wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nfunction isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nfunction setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nfunction setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nfunction setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap();\n\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    );\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    });\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        };\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node;\n            node = node.next;\n        }\n\n        // Add it.\n        prev.next = newNode;\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this);\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n\n        let prev = null;\n        let node = listeners.get(eventName);\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return\n            }\n\n            prev = node;\n            node = node.next;\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            );\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err);\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent);\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n\n        return !wrappedEvent.defaultPrevented\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nfunction normalizeOptions(options) {\r\n    var capture = false;\r\n    var passive;\r\n    var once;\r\n    if (typeof options === \"boolean\") {\r\n        capture = options;\r\n    }\r\n    else if (options != null) {\r\n        capture = !!options.capture;\r\n        passive = options.passive;\r\n        once = options.once;\r\n    }\r\n    return { capture: capture, passive: passive, once: once };\r\n}\r\nfunction isEventTarget(value) {\r\n    return (value !== null &&\r\n        typeof value === \"object\" &&\r\n        typeof value.addEventListener === \"function\" &&\r\n        // TODO: maybe we don’t need these checks\r\n        typeof value.removeEventListener === \"function\" &&\r\n        typeof value.dispatchEvent === \"function\");\r\n}\r\nvar CrankEventTarget = /** @class */ (function (_super) {\r\n    __extends(CrankEventTarget, _super);\r\n    function CrankEventTarget(parent) {\r\n        var _this = _super.call(this) || this;\r\n        _this.parent = parent;\r\n        // TODO: maybe use a helper class?\r\n        // we need a map from:\r\n        // type -> capture -> listener record\r\n        // for efficient querying\r\n        _this.listeners = [];\r\n        _this.delegates = new Set();\r\n        return _this;\r\n    }\r\n    CrankEventTarget.prototype.setDelegates = function (delegates) {\r\n        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;\r\n        var _this = this;\r\n        var delegates1 = new Set(Array.from(delegates).filter(isEventTarget));\r\n        var removed = new Set(Array.from(this.delegates).filter(function (d) { return !delegates1.has(d); }));\r\n        var added = new Set(Array.from(delegates1).filter(function (d) { return !_this.delegates.has(d); }));\r\n        try {\r\n            for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {\r\n                var delegate = removed_1_1.value;\r\n                try {\r\n                    for (var _e = (e_2 = void 0, __values(this.listeners)), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                        var listener = _f.value;\r\n                        delegate.removeEventListener(listener.type, listener.callback, listener.options);\r\n                    }\r\n                }\r\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (removed_1_1 && !removed_1_1.done && (_a = removed_1.return)) _a.call(removed_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        try {\r\n            for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {\r\n                var delegate = added_1_1.value;\r\n                try {\r\n                    for (var _g = (e_4 = void 0, __values(this.listeners)), _h = _g.next(); !_h.done; _h = _g.next()) {\r\n                        var listener = _h.value;\r\n                        delegate.addEventListener(listener.type, listener.callback, listener.options);\r\n                    }\r\n                }\r\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_h && !_h.done && (_d = _g.return)) _d.call(_g);\r\n                    }\r\n                    finally { if (e_4) throw e_4.error; }\r\n                }\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (added_1_1 && !added_1_1.done && (_c = added_1.return)) _c.call(added_1);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n        this.delegates = delegates1;\r\n    };\r\n    CrankEventTarget.prototype.addEventListener = function (type, callback, options) {\r\n        var e_5, _a;\r\n        if (callback == null) {\r\n            return;\r\n        }\r\n        else if (typeof callback === \"object\") {\r\n            throw new Error(\"Listener objects are not supported\");\r\n        }\r\n        options = normalizeOptions(options);\r\n        var record = { type: type, callback: callback, options: options };\r\n        if (options.once) {\r\n            var self_1 = this;\r\n            record.callback = function (ev) {\r\n                var result = callback.call(this, ev);\r\n                self_1.removeEventListener(record.type, record.callback, record.options);\r\n                return result;\r\n            };\r\n        }\r\n        if (record.type.slice(0, 6) !== \"crank.\") {\r\n            var idx = this.listeners.findIndex(function (record1) {\r\n                return (record.type === record1.type &&\r\n                    record.callback === record1.callback &&\r\n                    record.options.capture === record1.options.capture);\r\n            });\r\n            if (idx <= -1) {\r\n                this.listeners.push(record);\r\n            }\r\n        }\r\n        try {\r\n            for (var _b = __values(this.delegates), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var delegate = _c.value;\r\n                delegate.addEventListener(type, callback, options);\r\n            }\r\n        }\r\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_5) throw e_5.error; }\r\n        }\r\n        return _super.prototype.addEventListener.call(this, type, callback, options);\r\n    };\r\n    CrankEventTarget.prototype.removeEventListener = function (type, callback, options) {\r\n        var e_6, _a;\r\n        if (callback == null) {\r\n            return;\r\n        }\r\n        var capture = typeof options === \"boolean\" ? options : !!(options && options.capture);\r\n        var idx = this.listeners.findIndex(function (record) {\r\n            return (record.type === type &&\r\n                record.callback === callback &&\r\n                record.options.capture === capture);\r\n        });\r\n        var record = this.listeners[idx];\r\n        if (record !== undefined) {\r\n            this.listeners.splice(idx, 1);\r\n        }\r\n        try {\r\n            for (var _b = __values(this.delegates), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var delegate = _c.value;\r\n                delegate.removeEventListener(type, callback, options);\r\n            }\r\n        }\r\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_6) throw e_6.error; }\r\n        }\r\n        return _super.prototype.removeEventListener.call(this, type, callback, options);\r\n    };\r\n    CrankEventTarget.prototype.clearEventListeners = function () {\r\n        var e_7, _a;\r\n        try {\r\n            for (var _b = __values(this.listeners.slice()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var listener = _c.value;\r\n                this.removeEventListener(listener.type, listener.callback, listener.options);\r\n            }\r\n        }\r\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_7) throw e_7.error; }\r\n        }\r\n    };\r\n    // TODO: ev is any because event-target-shim has a weird dispatchEvent type\r\n    CrankEventTarget.prototype.dispatchEvent = function (ev) {\r\n        var continued = _super.prototype.dispatchEvent.call(this, ev);\r\n        if (continued && ev.bubbles && this.parent !== undefined) {\r\n            // TODO: implement event capturing\r\n            continued = this.parent.dispatchEvent(ev);\r\n        }\r\n        return continued;\r\n    };\r\n    return CrankEventTarget;\r\n}(EventTarget));\n\nfunction isPromiseLike(value) {\r\n    return value != null && typeof value.then === \"function\";\r\n}\r\nfunction upgrade(value) {\r\n    if (isPromiseLike(value) && !(value instanceof Promise)) {\r\n        return Promise.resolve(value);\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * A pledge is like a promise, except it runs synchronously if possible.\r\n *\r\n * It is not meant to be exposed in APIs; rather, you should unwrap pledges to\r\n * a possible promise by calling Pledge.prototype.execute.\r\n */\r\nvar Pledge = /** @class */ (function () {\r\n    function Pledge(executor) {\r\n        this.executor = executor;\r\n    }\r\n    Pledge.prototype.then = function (onfulfilled, onrejected) {\r\n        var _this = this;\r\n        return new Pledge(function () {\r\n            try {\r\n                var value = _this.execute();\r\n                if (isPromiseLike(value)) {\r\n                    return value.then(onfulfilled, onrejected);\r\n                }\r\n                else if (onfulfilled == null) {\r\n                    return value;\r\n                }\r\n                return onfulfilled(value);\r\n            }\r\n            catch (err) {\r\n                if (onrejected == null) {\r\n                    throw err;\r\n                }\r\n                return onrejected(err);\r\n            }\r\n        });\r\n    };\r\n    Pledge.prototype.catch = function (onrejected) {\r\n        var _this = this;\r\n        return new Pledge(function () {\r\n            try {\r\n                var value = _this.execute();\r\n                if (isPromiseLike(value)) {\r\n                    return value.catch(onrejected);\r\n                }\r\n                return value;\r\n            }\r\n            catch (err) {\r\n                if (onrejected == null) {\r\n                    throw err;\r\n                }\r\n                return onrejected(err);\r\n            }\r\n        });\r\n    };\r\n    Pledge.prototype.finally = function (onfinally) {\r\n        var _this = this;\r\n        return new Pledge(function () {\r\n            try {\r\n                var value = _this.execute();\r\n                if (isPromiseLike(value)) {\r\n                    return value.finally(onfinally);\r\n                }\r\n                else if (onfinally != null) {\r\n                    onfinally();\r\n                }\r\n                return value;\r\n            }\r\n            catch (err) {\r\n                if (onfinally != null) {\r\n                    onfinally();\r\n                }\r\n                throw err;\r\n            }\r\n        });\r\n    };\r\n    Pledge.prototype.execute = function () {\r\n        return upgrade(this.executor());\r\n    };\r\n    Pledge.resolve = function (value) {\r\n        return new Pledge(function () { return value; });\r\n    };\r\n    return Pledge;\r\n}());\n\nvar _a;\r\nfunction isIterable(value) {\r\n    return value != null && typeof value[Symbol.iterator] === \"function\";\r\n}\r\nfunction isNonStringIterable(value) {\r\n    return typeof value !== \"string\" && isIterable(value);\r\n}\r\nfunction isIteratorOrAsyncIterator(value) {\r\n    return value != null && typeof value.next === \"function\";\r\n}\r\nvar ElementSigil = Symbol.for(\"crank.ElementSigil\");\r\n// Special Intrinsic Tags\r\n// TODO: We assert symbol tags as any because typescript support for symbol\r\n// tags in JSX does not exist yet.\r\nvar Fragment = Symbol.for(\"crank.Fragment\");\r\nvar Copy = Symbol(\"crank.Copy\");\r\nvar Portal = Symbol.for(\"crank.Portal\");\r\nvar Raw = Symbol.for(\"crank.Raw\");\r\nfunction isElement(value) {\r\n    return value != null && value[ElementSigil];\r\n}\r\nfunction createElement(tag, props) {\r\n    var _a;\r\n    props = Object.assign({}, props);\r\n    var key = props[\"crank-key\"];\r\n    if (key != null) {\r\n        delete props[\"crank-key\"];\r\n    }\r\n    if (arguments.length > 3) {\r\n        props.children = Array.from(arguments).slice(2);\r\n    }\r\n    else if (arguments.length > 2) {\r\n        props.children = arguments[2];\r\n    }\r\n    return _a = {}, _a[ElementSigil] = true, _a.tag = tag, _a.props = props, _a.key = key, _a;\r\n}\r\nfunction normalize(child) {\r\n    if (child == null || typeof child === \"boolean\") {\r\n        return undefined;\r\n    }\r\n    else if (typeof child === \"string\" || isElement(child)) {\r\n        return child;\r\n    }\r\n    else {\r\n        return child.toString();\r\n    }\r\n}\r\nfunction flatten(children) {\r\n    var children_1, children_1_1, child, e_1_1;\r\n    var e_1, _a;\r\n    return __generator(this, function (_b) {\r\n        switch (_b.label) {\r\n            case 0:\r\n                if (!(children == null)) return [3 /*break*/, 1];\r\n                return [2 /*return*/];\r\n            case 1:\r\n                if (!!isNonStringIterable(children)) return [3 /*break*/, 3];\r\n                return [4 /*yield*/, normalize(children)];\r\n            case 2:\r\n                _b.sent();\r\n                return [2 /*return*/];\r\n            case 3:\r\n                _b.trys.push([3, 10, 11, 12]);\r\n                children_1 = __values(children), children_1_1 = children_1.next();\r\n                _b.label = 4;\r\n            case 4:\r\n                if (!!children_1_1.done) return [3 /*break*/, 9];\r\n                child = children_1_1.value;\r\n                if (!isNonStringIterable(child)) return [3 /*break*/, 6];\r\n                return [4 /*yield*/, createElement(Fragment, null, child)];\r\n            case 5:\r\n                _b.sent();\r\n                return [3 /*break*/, 8];\r\n            case 6: return [4 /*yield*/, normalize(child)];\r\n            case 7:\r\n                _b.sent();\r\n                _b.label = 8;\r\n            case 8:\r\n                children_1_1 = children_1.next();\r\n                return [3 /*break*/, 4];\r\n            case 9: return [3 /*break*/, 12];\r\n            case 10:\r\n                e_1_1 = _b.sent();\r\n                e_1 = { error: e_1_1 };\r\n                return [3 /*break*/, 12];\r\n            case 11:\r\n                try {\r\n                    if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n                return [7 /*endfinally*/];\r\n            case 12: return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\nvar LeafNode = /** @class */ (function () {\r\n    function LeafNode() {\r\n        this.internal = false;\r\n        this.tag = undefined;\r\n        this.key = undefined;\r\n        this.nextSibling = undefined;\r\n        this.previousSibling = undefined;\r\n        this.clock = 0;\r\n        this.replacedBy = undefined;\r\n        this.value = undefined;\r\n    }\r\n    return LeafNode;\r\n}());\r\nvar ParentNode = /** @class */ (function () {\r\n    function ParentNode() {\r\n        this.internal = true;\r\n        this.key = undefined;\r\n        this.nextSibling = undefined;\r\n        this.previousSibling = undefined;\r\n        this.clock = 0;\r\n        this.replacedBy = undefined;\r\n        this.firstChild = undefined;\r\n        this.lastChild = undefined;\r\n        this.keyedChildren = undefined;\r\n        // When children update asynchronously, we race their result against the next\r\n        // update of children. The onNextChildren property is set to the resolve\r\n        // function of the promise which the current update is raced against.\r\n        this.onNextChildren = undefined;\r\n        this.props = undefined;\r\n        this.value = undefined;\r\n        this.ctx = undefined;\r\n        this.updating = false;\r\n        this.iterating = false;\r\n        this.finished = false;\r\n        this.unmounted = false;\r\n    }\r\n    ParentNode.prototype.appendChild = function (child) {\r\n        if (this.lastChild === undefined) {\r\n            this.firstChild = child;\r\n            this.lastChild = child;\r\n            child.previousSibling = undefined;\r\n            child.nextSibling = undefined;\r\n        }\r\n        else {\r\n            child.previousSibling = this.lastChild;\r\n            child.nextSibling = undefined;\r\n            this.lastChild.nextSibling = child;\r\n            this.lastChild = child;\r\n        }\r\n    };\r\n    ParentNode.prototype.insertBefore = function (child, reference) {\r\n        if (reference == null) {\r\n            this.appendChild(child);\r\n            return;\r\n        }\r\n        else if (child === reference) {\r\n            return;\r\n        }\r\n        child.nextSibling = reference;\r\n        if (reference.previousSibling === undefined) {\r\n            child.previousSibling = undefined;\r\n            this.firstChild = child;\r\n        }\r\n        else {\r\n            child.previousSibling = reference.previousSibling;\r\n            reference.previousSibling.nextSibling = child;\r\n        }\r\n        reference.previousSibling = child;\r\n    };\r\n    ParentNode.prototype.removeChild = function (child) {\r\n        if (child.previousSibling === undefined) {\r\n            this.firstChild = child.nextSibling;\r\n        }\r\n        else {\r\n            child.previousSibling.nextSibling = child.nextSibling;\r\n        }\r\n        if (child.nextSibling === undefined) {\r\n            this.lastChild = child.previousSibling;\r\n        }\r\n        else {\r\n            child.nextSibling.previousSibling = child.previousSibling;\r\n        }\r\n        child.previousSibling = undefined;\r\n        child.nextSibling = undefined;\r\n    };\r\n    ParentNode.prototype.replaceChild = function (child, reference) {\r\n        this.insertBefore(child, reference);\r\n        this.removeChild(reference);\r\n    };\r\n    ParentNode.prototype.getChildValues = function () {\r\n        var buffer;\r\n        var childValues = [];\r\n        for (var child = this.firstChild; child != null; child = child.nextSibling) {\r\n            if (typeof child.value === \"string\") {\r\n                buffer = (buffer || \"\") + child.value;\r\n            }\r\n            else if (child.tag !== Portal) {\r\n                if (buffer !== undefined) {\r\n                    childValues.push(buffer);\r\n                    buffer = undefined;\r\n                }\r\n                if (Array.isArray(child.value)) {\r\n                    childValues.push.apply(childValues, __spread(child.value));\r\n                }\r\n                else if (child.value !== undefined) {\r\n                    childValues.push(child.value);\r\n                }\r\n            }\r\n        }\r\n        if (buffer !== undefined) {\r\n            childValues.push(buffer);\r\n        }\r\n        return childValues;\r\n    };\r\n    // TODO: I bet we could simplify the algorithm further, perhaps by writing a\r\n    // custom a method which automatically zips up old and new nodes.\r\n    ParentNode.prototype.updateChildren = function (children) {\r\n        var e_2, _a, e_3, _b;\r\n        var _this = this;\r\n        var host = this.firstChild;\r\n        var nextSibling = host && host.nextSibling;\r\n        var nextKeyedChildren;\r\n        var updates;\r\n        var _loop_1 = function (child) {\r\n            var tag = void 0;\r\n            var key = void 0;\r\n            if (isElement(child)) {\r\n                tag = child.tag;\r\n                key = child.key;\r\n                if (nextKeyedChildren !== undefined && nextKeyedChildren.has(key)) {\r\n                    key = undefined;\r\n                }\r\n            }\r\n            if (key != null) {\r\n                var nextNode = this_1.keyedChildren && this_1.keyedChildren.get(key);\r\n                if (nextNode === undefined) {\r\n                    nextNode = createNode(this_1, this_1.renderer, child);\r\n                }\r\n                else {\r\n                    this_1.keyedChildren.delete(key);\r\n                    if (host !== nextNode) {\r\n                        this_1.removeChild(nextNode);\r\n                    }\r\n                }\r\n                if (host === undefined) {\r\n                    this_1.appendChild(nextNode);\r\n                }\r\n                else if (host !== nextNode) {\r\n                    if (host.key == null) {\r\n                        this_1.insertBefore(nextNode, host);\r\n                    }\r\n                    else {\r\n                        this_1.insertBefore(nextNode, host.nextSibling);\r\n                    }\r\n                }\r\n                host = nextNode;\r\n                nextSibling = host.nextSibling;\r\n            }\r\n            else if (host === undefined) {\r\n                host = createNode(this_1, this_1.renderer, child);\r\n                this_1.appendChild(host);\r\n            }\r\n            else if (host.key != null) {\r\n                var nextNode = createNode(this_1, this_1.renderer, child);\r\n                this_1.insertBefore(nextNode, host.nextSibling);\r\n                host = nextNode;\r\n                nextSibling = host.nextSibling;\r\n            }\r\n            if (tag !== Copy) {\r\n                // TODO: figure out why do we do a check for unmounted hosts here\r\n                if (host.tag === tag && !(host.internal && host.unmounted)) {\r\n                    if (host.internal) {\r\n                        var update = host.update(child.props);\r\n                        if (update !== undefined) {\r\n                            if (updates === undefined) {\r\n                                updates = [];\r\n                            }\r\n                            updates.push(update);\r\n                        }\r\n                    }\r\n                    else if (typeof child === \"string\") {\r\n                        host.value = this_1.renderer.text(child);\r\n                    }\r\n                    else {\r\n                        host.value = undefined;\r\n                    }\r\n                }\r\n                else {\r\n                    // TODO: async unmount for keyed hosts\r\n                    if (host.internal) {\r\n                        host.unmount();\r\n                    }\r\n                    var nextNode_1 = createNode(this_1, this_1.renderer, child);\r\n                    nextNode_1.clock = host.clock++;\r\n                    var update = void 0;\r\n                    if (nextNode_1.internal) {\r\n                        update = nextNode_1.update(child.props);\r\n                    }\r\n                    else if (typeof child === \"string\") {\r\n                        nextNode_1.value = this_1.renderer.text(child);\r\n                    }\r\n                    else {\r\n                        nextNode_1.value = undefined;\r\n                    }\r\n                    if (update === undefined) {\r\n                        this_1.replaceChild(nextNode_1, host);\r\n                        host.replacedBy = nextNode_1;\r\n                    }\r\n                    else {\r\n                        if (updates === undefined) {\r\n                            updates = [];\r\n                        }\r\n                        updates.push(update);\r\n                        // host is reassigned so we need to capture its current value in\r\n                        // host1 for the sake of the callback’s closure.\r\n                        var host1_1 = host;\r\n                        update.then(function () {\r\n                            if (host1_1.replacedBy === undefined) {\r\n                                _this.replaceChild(nextNode_1, host1_1);\r\n                                host1_1.replacedBy = nextNode_1;\r\n                            }\r\n                            else if (host1_1.replacedBy.replacedBy === undefined &&\r\n                                host1_1.replacedBy.clock < nextNode_1.clock) {\r\n                                _this.replaceChild(nextNode_1, host1_1.replacedBy);\r\n                                host1_1.replacedBy = nextNode_1;\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (key !== undefined) {\r\n                if (nextKeyedChildren === undefined) {\r\n                    nextKeyedChildren = new Map();\r\n                }\r\n                nextKeyedChildren.set(key, host);\r\n            }\r\n            host = nextSibling;\r\n            nextSibling = host && host.nextSibling;\r\n        };\r\n        var this_1 = this;\r\n        try {\r\n            for (var _c = __values(flatten(children)), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var child = _d.value;\r\n                _loop_1(child);\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        // unmount excess children\r\n        for (; host !== undefined; host = nextSibling, nextSibling = host && host.nextSibling) {\r\n            if (host.key !== undefined && this.keyedChildren !== undefined) {\r\n                this.keyedChildren.delete(host.key);\r\n            }\r\n            if (host.internal) {\r\n                host.unmount();\r\n            }\r\n            this.removeChild(host);\r\n        }\r\n        // unmount excess keyed children\r\n        if (this.keyedChildren !== undefined) {\r\n            try {\r\n                for (var _e = __values(this.keyedChildren.values()), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                    var child = _f.value;\r\n                    child.internal && child.unmount();\r\n                    this.removeChild(child);\r\n                }\r\n            }\r\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n                }\r\n                finally { if (e_3) throw e_3.error; }\r\n            }\r\n        }\r\n        this.keyedChildren = nextKeyedChildren;\r\n        if (updates === undefined) {\r\n            this.commit();\r\n            if (this.onNextChildren !== undefined) {\r\n                this.onNextChildren();\r\n                this.onNextChildren = undefined;\r\n            }\r\n        }\r\n        else {\r\n            var result = Promise.all(updates).then(function () { return void _this.commit(); }); // void :(\r\n            if (this.onNextChildren !== undefined) {\r\n                this.onNextChildren(result);\r\n                this.onNextChildren = undefined;\r\n            }\r\n            var nextResult = new Promise(function (resolve) { return (_this.onNextChildren = resolve); });\r\n            return Promise.race([result, nextResult]);\r\n        }\r\n    };\r\n    ParentNode.prototype.unmountChildren = function () {\r\n        for (var host = this.firstChild; host !== undefined; host = host.nextSibling) {\r\n            if (host.internal) {\r\n                host.unmount();\r\n            }\r\n        }\r\n    };\r\n    ParentNode.prototype.update = function (props) {\r\n        this.props = props;\r\n        this.updating = true;\r\n        return this.refresh();\r\n    };\r\n    ParentNode.prototype.refresh = function () {\r\n        if (this.unmounted) {\r\n            return;\r\n        }\r\n        return this.updateChildren(this.props && this.props.children);\r\n    };\r\n    ParentNode.prototype.catch = function (reason) {\r\n        if (this.parent === undefined) {\r\n            throw reason;\r\n        }\r\n        return this.parent.catch(reason);\r\n    };\r\n    return ParentNode;\r\n}());\r\nvar FragmentNode = /** @class */ (function (_super) {\r\n    __extends(FragmentNode, _super);\r\n    function FragmentNode(parent, renderer, key) {\r\n        var _this = _super.call(this) || this;\r\n        _this.tag = Fragment;\r\n        _this.key = key;\r\n        _this.parent = parent;\r\n        _this.renderer = renderer;\r\n        _this.ctx = parent.ctx;\r\n        return _this;\r\n    }\r\n    FragmentNode.prototype.commit = function () {\r\n        var childValues = this.getChildValues();\r\n        this.value = childValues.length > 1 ? childValues : childValues[0];\r\n        if (!this.updating) {\r\n            // TODO: batch this per microtask\r\n            this.parent.commit();\r\n        }\r\n        this.updating = false;\r\n        return; // void :(\r\n    };\r\n    FragmentNode.prototype.unmount = function () {\r\n        if (this.unmounted) {\r\n            return;\r\n        }\r\n        this.unmounted = true;\r\n        this.unmountChildren();\r\n    };\r\n    return FragmentNode;\r\n}(ParentNode));\r\nvar HostNode = /** @class */ (function (_super) {\r\n    __extends(HostNode, _super);\r\n    function HostNode(parent, renderer, tag, key) {\r\n        var _this = _super.call(this) || this;\r\n        _this.childValues = [];\r\n        _this.iterator = undefined;\r\n        _this.tag = tag;\r\n        _this.key = key;\r\n        _this.parent = parent;\r\n        _this.renderer = renderer;\r\n        _this.intrinsic = renderer.intrinsic(tag);\r\n        _this.ctx = parent && parent.ctx;\r\n        _this.hostCtx = new HostContext(_this);\r\n        return _this;\r\n    }\r\n    HostNode.prototype.commit = function () {\r\n        this.childValues = this.getChildValues();\r\n        try {\r\n            if (this.iterator === undefined) {\r\n                var value = this.intrinsic.call(this.hostCtx, exports.__assign(exports.__assign({}, this.props), { children: this.childValues }));\r\n                if (isIteratorOrAsyncIterator(value)) {\r\n                    this.iterator = value;\r\n                }\r\n                else {\r\n                    this.value = value;\r\n                }\r\n            }\r\n            if (this.iterator !== undefined) {\r\n                var iteration = this.iterator.next();\r\n                this.value = iteration.value;\r\n                this.iterating = false;\r\n                if (iteration.done) {\r\n                    this.finished = true;\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (this.parent !== undefined) {\r\n                return this.parent.catch(err);\r\n            }\r\n            throw err;\r\n        }\r\n        finally {\r\n            this.updating = false;\r\n        }\r\n    };\r\n    HostNode.prototype.unmount = function () {\r\n        if (this.unmounted) {\r\n            return;\r\n        }\r\n        else if (this.finished) {\r\n            if (this.iterator !== undefined && this.iterator.return) {\r\n                try {\r\n                    this.iterator.return();\r\n                }\r\n                catch (err) {\r\n                    if (this.parent !== undefined) {\r\n                        this.parent.catch(err);\r\n                    }\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n        this.unmounted = true;\r\n        this.unmountChildren();\r\n    };\r\n    HostNode.prototype[Symbol.iterator] = function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!!this.unmounted) return [3 /*break*/, 2];\r\n                    if (this.iterating) {\r\n                        throw new Error(\"You must yield something each iteration over context\");\r\n                    }\r\n                    this.iterating = true;\r\n                    return [4 /*yield*/, exports.__assign(exports.__assign({}, this.props), { children: this.childValues })];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 0];\r\n                case 2: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return HostNode;\r\n}(ParentNode));\r\nvar AsyncFn = 1;\r\nvar SyncGen = 2;\r\nvar AsyncGen = 3;\r\nvar ComponentNode = /** @class */ (function (_super) {\r\n    __extends(ComponentNode, _super);\r\n    function ComponentNode(parent, renderer, tag, key) {\r\n        var _this = _super.call(this) || this;\r\n        _this.available = true;\r\n        _this.iterator = undefined;\r\n        // TODO: explain these properties\r\n        _this.componentType = undefined;\r\n        _this.inflightPending = undefined;\r\n        _this.enqueuedPending = undefined;\r\n        _this.inflightResult = undefined;\r\n        _this.enqueuedResult = undefined;\r\n        _this.previousResult = undefined;\r\n        _this.provisions = undefined;\r\n        _this.publish = undefined;\r\n        _this.parent = parent;\r\n        _this.renderer = renderer;\r\n        _this.tag = tag;\r\n        _this.key = key;\r\n        _this.ctx = new Context(_this, parent.ctx);\r\n        return _this;\r\n    }\r\n    ComponentNode.prototype.step = function () {\r\n        var _this = this;\r\n        if (this.finished) {\r\n            return [undefined, undefined];\r\n        }\r\n        else if (this.iterator === undefined) {\r\n            this.ctx.clearEventListeners();\r\n            var value = new Pledge(function () { return _this.tag.call(_this.ctx, _this.props); })\r\n                .catch(function (err) { return _this.parent.catch(err); })\r\n                // type assertion because we shouldn’t get a promise of an iterator\r\n                .execute();\r\n            if (isIteratorOrAsyncIterator(value)) {\r\n                this.iterator = value;\r\n            }\r\n            else if (isPromiseLike(value)) {\r\n                this.componentType = AsyncFn;\r\n                var pending_1 = value.then(function () { return undefined; }); // void :(\r\n                var result = value.then(function (child) { return _this.updateChildren(child); });\r\n                return [pending_1, result];\r\n            }\r\n            else {\r\n                this.componentType = AsyncGen;\r\n                var result = this.updateChildren(value);\r\n                return [undefined, result];\r\n            }\r\n        }\r\n        var previousValue = Pledge.resolve(this.previousResult)\r\n            .then(function () { return _this.value; })\r\n            .execute();\r\n        var iteration = new Pledge(function () { return _this.iterator.next(previousValue); })\r\n            .catch(function (err) {\r\n            // TODO: figure out why this is written like this\r\n            return Pledge.resolve(_this.parent.catch(err))\r\n                .then(function () { return ({ value: undefined, done: true }); })\r\n                .execute();\r\n        })\r\n            .execute();\r\n        if (isPromiseLike(iteration)) {\r\n            this.componentType = AsyncGen;\r\n            var pending_2 = iteration.then(function (iteration) {\r\n                _this.iterating = false;\r\n                if (iteration.done) {\r\n                    _this.finished = true;\r\n                }\r\n                return undefined; // void :(\r\n            }, function () { return undefined; });\r\n            var result = iteration.then(function (iteration) {\r\n                _this.previousResult = _this.updateChildren(iteration.value);\r\n                return _this.previousResult;\r\n            });\r\n            return [pending_2, result];\r\n        }\r\n        else {\r\n            this.iterating = false;\r\n            this.componentType = SyncGen;\r\n            if (iteration.done) {\r\n                this.finished = true;\r\n            }\r\n            var result = this.updateChildren(iteration.value);\r\n            return [result, result];\r\n        }\r\n    };\r\n    ComponentNode.prototype.advance = function () {\r\n        this.inflightPending = this.enqueuedPending;\r\n        this.inflightResult = this.enqueuedResult;\r\n        this.enqueuedPending = undefined;\r\n        this.enqueuedResult = undefined;\r\n        if (this.componentType === AsyncGen && !this.finished && !this.unmounted) {\r\n            this.run();\r\n        }\r\n    };\r\n    ComponentNode.prototype.refresh = function () {\r\n        if (this.unmounted) {\r\n            return;\r\n        }\r\n        if (this.publish === undefined) {\r\n            this.available = true;\r\n        }\r\n        else {\r\n            this.publish(this.props);\r\n            this.publish = undefined;\r\n        }\r\n        return this.run();\r\n    };\r\n    ComponentNode.prototype[Symbol.iterator] = function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!!this.unmounted) return [3 /*break*/, 2];\r\n                    if (this.iterating) {\r\n                        throw new Error(\"You must yield once per iteration over context\");\r\n                    }\r\n                    else if (this.componentType === AsyncGen) {\r\n                        throw new Error(\"Use for await...of in async generator components.\");\r\n                    }\r\n                    this.iterating = true;\r\n                    return [4 /*yield*/, this.props];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 0];\r\n                case 2: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    ComponentNode.prototype[Symbol.asyncIterator] = function () {\r\n        return __asyncGenerator(this, arguments, function _a() {\r\n            var props;\r\n            var _this = this;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        if (this.iterating) {\r\n                            throw new Error(\"You must yield once per iteration over context\");\r\n                        }\r\n                        else if (this.componentType === SyncGen) {\r\n                            throw new Error(\"Use for...of in sync generator components.\");\r\n                        }\r\n                        this.iterating = true;\r\n                        if (!this.available) return [3 /*break*/, 3];\r\n                        this.available = false;\r\n                        return [4 /*yield*/, __await(this.props)];\r\n                    case 1: return [4 /*yield*/, _b.sent()];\r\n                    case 2:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 7];\r\n                    case 3: return [4 /*yield*/, __await(new Promise(function (resolve) { return (_this.publish = resolve); }))];\r\n                    case 4:\r\n                        props = _b.sent();\r\n                        if (!!this.unmounted) return [3 /*break*/, 7];\r\n                        return [4 /*yield*/, __await(props)];\r\n                    case 5: return [4 /*yield*/, _b.sent()];\r\n                    case 6:\r\n                        _b.sent();\r\n                        _b.label = 7;\r\n                    case 7:\r\n                        if (!this.unmounted) return [3 /*break*/, 0];\r\n                        _b.label = 8;\r\n                    case 8: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ComponentNode.prototype.run = function () {\r\n        var _this = this;\r\n        if (this.inflightPending === undefined) {\r\n            var _a = __read(this.step(), 2), pending_3 = _a[0], result = _a[1];\r\n            if (isPromiseLike(pending_3)) {\r\n                this.inflightPending = pending_3.finally(function () { return _this.advance(); });\r\n            }\r\n            this.inflightResult = result;\r\n            return this.inflightResult;\r\n        }\r\n        else if (this.componentType === AsyncGen) {\r\n            return this.inflightResult;\r\n        }\r\n        else if (this.enqueuedPending === undefined) {\r\n            var resolve_1;\r\n            this.enqueuedPending = this.inflightPending\r\n                .then(function () {\r\n                var _a = __read(_this.step(), 2), pending = _a[0], result = _a[1];\r\n                resolve_1(result);\r\n                return pending;\r\n            })\r\n                .finally(function () { return _this.advance(); });\r\n            this.enqueuedResult = new Promise(function (resolve1) { return (resolve_1 = resolve1); });\r\n        }\r\n        return this.enqueuedResult;\r\n    };\r\n    ComponentNode.prototype.commit = function () {\r\n        var childValues = this.getChildValues();\r\n        this.ctx.setDelegates(childValues);\r\n        this.value = childValues.length > 1 ? childValues : childValues[0];\r\n        if (!this.updating) {\r\n            // TODO: batch this per macrotask\r\n            this.parent.commit();\r\n        }\r\n        this.updating = false;\r\n        return; // void :(\r\n    };\r\n    ComponentNode.prototype.unmount = function () {\r\n        var _this = this;\r\n        if (this.unmounted) {\r\n            return;\r\n        }\r\n        this.unmounted = true;\r\n        if (!this.finished) {\r\n            this.finished = true;\r\n            // TODO: maybe we should return the async iterator rather than\r\n            // republishing props\r\n            if (this.publish !== undefined) {\r\n                this.publish(this.props);\r\n                this.publish = undefined;\r\n            }\r\n            if (this.iterator !== undefined && this.iterator.return) {\r\n                return new Pledge(function () { return _this.iterator.return(); })\r\n                    .then(function () { return void _this.unmountChildren(); }, // void :(\r\n                function (err) { return _this.parent.catch(err); })\r\n                    .execute();\r\n            }\r\n        }\r\n        this.unmountChildren();\r\n    };\r\n    ComponentNode.prototype.catch = function (reason) {\r\n        var _this = this;\r\n        if (this.iterator === undefined ||\r\n            this.iterator.throw === undefined ||\r\n            this.finished) {\r\n            return _super.prototype.catch.call(this, reason);\r\n        }\r\n        else {\r\n            return new Pledge(function () { return _this.iterator.throw(reason); })\r\n                .then(function (iteration) {\r\n                if (iteration.done) {\r\n                    _this.finished = true;\r\n                }\r\n                return _this.updateChildren(iteration.value);\r\n            })\r\n                .catch(function (err) { return _this.parent.catch(err); })\r\n                .execute();\r\n        }\r\n    };\r\n    ComponentNode.prototype.get = function (name) {\r\n        for (var host = this.parent; host !== undefined; host = host.parent) {\r\n            if (host instanceof ComponentNode &&\r\n                host.provisions !== undefined &&\r\n                host.provisions.has(name)) {\r\n                return host.provisions.get(name);\r\n            }\r\n        }\r\n    };\r\n    ComponentNode.prototype.set = function (name, value) {\r\n        if (this.provisions === undefined) {\r\n            this.provisions = new Map();\r\n        }\r\n        this.provisions.set(name, value);\r\n    };\r\n    return ComponentNode;\r\n}(ParentNode));\r\nfunction createNode(parent, renderer, child) {\r\n    if (child === undefined || typeof child === \"string\") {\r\n        return new LeafNode();\r\n    }\r\n    else if (child.tag === Fragment) {\r\n        return new FragmentNode(parent, renderer, child.key);\r\n    }\r\n    else if (typeof child.tag === \"function\") {\r\n        return new ComponentNode(parent, renderer, child.tag, child.key);\r\n    }\r\n    else {\r\n        return new HostNode(parent, renderer, child.tag, child.key);\r\n    }\r\n}\r\nvar hostNodes = new WeakMap();\r\nvar HostContext = /** @class */ (function () {\r\n    function HostContext(host) {\r\n        hostNodes.set(this, host);\r\n    }\r\n    HostContext.prototype[Symbol.iterator] = function () {\r\n        return hostNodes.get(this)[Symbol.iterator]();\r\n    };\r\n    return HostContext;\r\n}());\r\nvar componentNodes = new WeakMap();\r\nvar Context = /** @class */ (function (_super) {\r\n    __extends(Context, _super);\r\n    function Context(host, parent) {\r\n        var _this = _super.call(this, parent) || this;\r\n        componentNodes.set(_this, host);\r\n        return _this;\r\n    }\r\n    Context.prototype.get = function (name) {\r\n        return componentNodes.get(this).get(name);\r\n    };\r\n    Context.prototype.set = function (name, value) {\r\n        componentNodes.get(this).set(name, value);\r\n    };\r\n    /* eslint-enable no-dupe-class-members */\r\n    Context.prototype[Symbol.iterator] = function () {\r\n        return componentNodes.get(this)[Symbol.iterator]();\r\n    };\r\n    Context.prototype[Symbol.asyncIterator] = function () {\r\n        return componentNodes.get(this)[Symbol.asyncIterator]();\r\n    };\r\n    Context.prototype.refresh = function () {\r\n        return componentNodes.get(this).refresh();\r\n    };\r\n    return Context;\r\n}(CrankEventTarget));\r\nvar Default = Symbol.for(\"crank.Default\");\r\nvar Text = Symbol.for(\"crank.Text\");\r\nvar defaultEnv = (_a = {},\r\n    _a[Default] = function (tag) {\r\n        throw new Error(\"Environment did not provide an intrinsic for tag: \" + tag);\r\n    },\r\n    _a[Portal] = function () {\r\n        throw new Error(\"Environment did not provide an intrinsic for Portal\");\r\n    },\r\n    _a[Raw] = function (_a) {\r\n        var value = _a.value;\r\n        return value;\r\n    },\r\n    _a);\r\nvar Renderer = /** @class */ (function () {\r\n    function Renderer(env) {\r\n        this.cache = new WeakMap();\r\n        this.env = exports.__assign({}, defaultEnv);\r\n        if (env) {\r\n            this.extend(env);\r\n        }\r\n    }\r\n    Renderer.prototype.extend = function (env) {\r\n        var e_4, _a, e_5, _b;\r\n        try {\r\n            for (var _c = __values(Object.getOwnPropertySymbols(env)), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var sym = _d.value;\r\n                if (env[sym] != null) {\r\n                    this.env[sym] = env[sym];\r\n                }\r\n            }\r\n        }\r\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_4) throw e_4.error; }\r\n        }\r\n        try {\r\n            for (var _e = __values(Object.keys(env)), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                var tag = _f.value;\r\n                if (env[tag] != null) {\r\n                    this.env[tag] = env[tag];\r\n                }\r\n            }\r\n        }\r\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n        finally {\r\n            try {\r\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n            }\r\n            finally { if (e_5) throw e_5.error; }\r\n        }\r\n    };\r\n    Renderer.prototype.render = function (child, root) {\r\n        var portal;\r\n        if (isElement(child) && child.tag === Portal) {\r\n            portal = child;\r\n        }\r\n        else {\r\n            portal = createElement(Portal, { root: root }, child);\r\n        }\r\n        var host = root != null ? this.cache.get(root) : undefined;\r\n        if (host === undefined) {\r\n            host = new HostNode(undefined, this, portal.tag);\r\n            if (root !== undefined) {\r\n                this.cache.set(root, host);\r\n            }\r\n        }\r\n        return Pledge.resolve(host.update(portal.props))\r\n            .then(function () { return host.value; })\r\n            .execute();\r\n    };\r\n    // TODO: Ideally, the intrinsic and text methods should not be exposed\r\n    // outside this module\r\n    Renderer.prototype.intrinsic = function (tag) {\r\n        if (this.env[tag]) {\r\n            return this.env[tag];\r\n        }\r\n        else if (typeof tag === \"string\") {\r\n            return this.env[Default](tag);\r\n        }\r\n        else {\r\n            throw new Error(\"Unknown tag: \" + tag.toString());\r\n        }\r\n    };\r\n    Renderer.prototype.text = function (text) {\r\n        if (this.env[Text] !== undefined) {\r\n            return this.env[Text](text);\r\n        }\r\n        return text;\r\n    };\r\n    return Renderer;\r\n}());\n\nexports.Context = Context;\nexports.Copy = Copy;\nexports.Default = Default;\nexports.Fragment = Fragment;\nexports.HostContext = HostContext;\nexports.Portal = Portal;\nexports.Raw = Raw;\nexports.Renderer = Renderer;\nexports.Text = Text;\nexports.__extends = __extends;\nexports.__generator = __generator;\nexports.__read = __read;\nexports.__rest = __rest;\nexports.__values = __values;\nexports.createElement = createElement;\nexports.isElement = isElement;\n\n"},"sourceMaps":{"js":{"version":3,"file":"index-454299da.js","sources":["../node_modules/event-target-shim/dist/event-target-shim.mjs"],"sourcesContent":["/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap();\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event);\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    );\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            );\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    });\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true });\n\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this));\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype);\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event);\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value;\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    });\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            );\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nfunction wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nfunction isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nfunction setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nfunction setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nfunction setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap();\n\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    );\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    });\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        };\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node;\n            node = node.next;\n        }\n\n        // Add it.\n        prev.next = newNode;\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this);\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n\n        let prev = null;\n        let node = listeners.get(eventName);\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return\n            }\n\n            prev = node;\n            node = node.next;\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            );\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err);\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent);\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n\n        return !wrappedEvent.defaultPrevented\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };\n//# sourceMappingURL=event-target-shim.mjs.map\n"],"names":[],"mappings":"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"}},"error":null,"hash":"ab1fbb8c851dde1affe70dfeb744ec74","cacheData":{"env":{}}}